## [The `app` Directory](#the-app-directory)

In version 13, Next.js introduced a new **App Router** built on [React Server Components](/docs/getting-started/react-essentials#server-components), which supports shared layouts, nested routing, loading states, error handling, and more.

The App Router works in a new directory named `app`. The `app` directory works alongside the `pages` directory to allow for incremental adoption. This allows you to opt some routes of your application into the new behavior while keeping other routes in the `pages` directory for previous behavior.

> **Good to know:** The App Router takes priority over the Pages Router. Routes across directories should not resolve to the same URL path and will cause a build-time error to prevent a conflict.

By default, components inside `app` are [React Server Components](/docs/getting-started/react-essentials#server-components). This is a performance optimization and allows you to easily adopt them, and you can also use [Client Components](/docs/getting-started/react-essentials#client-components).

## [Roles of Folders and Files](#roles-of-folders-and-files)

- **Folders** are used to define routes. A route is a single path of nested folders, following the hierarchy from the **root folder** down to a final **leaf folder** that includes a `page.js` file.
- **Files** are used to create UI that is shown for the route segment. See [special files](https://nextjs.org/docs/app/building-your-application/routing#file-conventions).

## [File Conventions](#file-conventions)

- [page.js](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#pages): Create the unique UI of a route and make the path publicly accessible.
  - [route.js](https://nextjs.org/docs/app/building-your-application/routing/router-handlers): Create server-side API endpoints for a route.
- [layout.js](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts): Create shared UI for a segment and its children. A layout wraps a page or child segment.
  - [template.js](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#templates): Similar to `layout.js`, except a new component instance is mounted on navigation. Use layouts unless you need this behavior.
- [loading.js](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming): Create loading UI for a segment and its children. `loading.js` wraps a page or child segment in a [React Suspense Boundary](https://react.dev/reference/react/Suspense#suspense), showing the loading UI while they load.
- [error.js](https://nextjs.org/docs/app/building-your-application/routing/error-handling): Create error UI for a segment and its children. `error.js` wraps a page or child segment in a [React Error Boundary](https://reactjs.org/docs/error-boundaries.html), showing the error UI if an error is caught.
  - [global-error.js](https://nextjs.org/docs/app/building-your-application/routing/error-handling): Similar to `error.js`, but specifically for catching errors in the root `layout.js`.
- [not-found.js](https://nextjs.org/docs/app/api-reference/file-conventions/not-found): Create UI to show when the [`notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found) function is thrown within a route segment or when a URL is not matched by any route.

## [Component Hierarchy](#component-hierarchy)

- `layout.js`
- `template.js`
- `error.js` (React error boundary)
- `loading.js` (React suspense boundary)
- `not-found.js` (React error boundary)
- `page.js` or nested `layout.js`

![Component Hierarchy for File Conventions](/assets/file-conventions-component-hierarchy.avif)
In a nested route, the components of a segment will be nested **inside** the components of its parent segment.

![Nested File Conventions Component Hierarchy](/assets/nested-file-conventions-component-hierarchy.avif)

## [Colocation](#colocation)

In addition to special files, you have the option to colocate your own files inside folders. For example, stylesheets, tests, components, and more.

![Component colocation inside the App Router](/assets/component-collocation.avif)

## [Server-Centric Routing with Client-side Navigation](#server-centric-routing-with-client-side-navigation)

Unlike the `pages` directory which uses client-side routing, the App Router uses **server-centric routing** to align with [Server Components](/docs/getting-started/react-essentials#server-components) and [data fetching on the server](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching). With server-centric routing, the client does not have to download a route map and the same request for Server Components can be used to look up routes. This optimization is useful for all applications, but has a larger impact on applications with many routes.

Although routing is server-centric, the router uses **client-side navigation** with the [Link Component](https://nextjs.org/docs/app/building-your-application/routing/NavLinking-and-navigating#linking) - resembling the behavior of a Single-Page Application. This means when a user navigates to a new route, the browser will not reload the page. Instead, the URL will be updated and Next.js will [only render the segments that change](https://nextjs.org/docs/app/building-your-application/routing#partial-rendering).

Additionally, as users navigate around the app, the router will store the result of the React Server Component payload in an **in-memory client-side cache**. The cache is split by route segments which allows invalidation at any level and ensures consistency across [React's concurrent renders](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react). This means that for certain cases, the cache of a previously fetched segment can be re-used, further improving performance.

## [Partial Rendering](#partial-rendering)

When navigating between sibling routes (e.g. `/dashboard/settings` and `/dashboard/analytics` below), Next.js will only fetch and render the layouts and pages in routes that change. It will **not** re-fetch or re-render anything above the segments in the subtree. This means that in routes that share a layout, the layout will be preserved when a user navigates between sibling pages.

![How partial rendering works](/assets/partial-rendering.avif)

Without partial rendering, each navigation would cause the full page to re-render on the server. Rendering only the segment thatâ€™s updating reduces the amount of data transferred and execution time, leading to improved performance.

## [Advanced Routing Patterns](#advanced-routing-patterns)

- [Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes): Allow you to simultaneously show two or more pages in the same view that can be navigated independently. You can use them for split views that have their own sub-navigation. E.g. Dashboards.
- [Intercepting Routes](https://nextjs.orghttps://nextjs.org/docs/app/building-your-application/routing/intercepting-routes): Allow you to intercept a route and show it in the context of another route. You can use these when keeping the context for the current page is important. E.g. Seeing all tasks while editing one task or expanding a photo in a feed.

# Route Handlers

> **Good to know:** Route Handlers are only available inside the `app` directory. They are the equivalent of [API Routes](/docs/pages/building-your-application/routing/api-routes) inside the `pages` directory meaning you **do not** need to use API Routes and Route Handlers together.

## [Convention](#convention)

Route Handlers are defined in a [`route.js|ts` file](/docs/app/api-reference/file-conventions/route) inside the `app` directory:

app/api/route.ts

```ts
export async function GET(request: Request) {}
```

Route Handlers can be nested inside the `app` directory, similar to `page.js` and `layout.js`. But there **cannot** be a `route.js` file at the same route segment level as `page.js`.

### [Supported HTTP Methods](#supported-http-methods)

The following [HTTP methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) are supported: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS`. If an unsupported method is called, Next.js will return a `405 Method Not Allowed` response.

### [Extended `NextRequest` and `NextResponse` APIs](#extended-nextrequest-and-nextresponse-apis)

In addition to supporting native [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response). Next.js extends them with [`NextRequest`](/docs/app/api-reference/functions/next-request) and [`NextResponse`](/docs/app/api-reference/functions/next-response)

### [Static Route Handlers](#static-route-handlers)

Route Handlers are [statically evaluated](/docs/app/building-your-application/data-fetching#static-and-dynamic-data-fetches) by default when using the `GET` method with the `Response` object.

app/items/route.ts

```ts
import { NextResponse } from 'next/server';

export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  });
  const data = await res.json();

  return NextResponse.json({ data });
}
```

> **TypeScript Warning:** Although `Response.json()` is valid, native TypeScript types currently shows an error, you can use [`NextResponse.json()`](/docs/app/api-reference/functions/next-response#json) for typed responses instead.

### [Dynamic Route Handlers](#dynamic-route-handlers)

Route handlers are evaluated dynamically when:

- Using the `Request` object with the `GET` method.
- Using any of the other HTTP methods.
- Using [Dynamic Functions](/docs/app/building-your-application/routing/router-handlers#dynamic-functions) like `cookies` and `headers`.
- The [Segment Config Options](#segment-config-options) manually specifies dynamic mode.

app/products/api/route.ts

```ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const id = searchParams.get('id');
  const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  });
  const product = await res.json();

  return NextResponse.json({ product });
}
```

Similarly, the `POST` method will cause the Route Handler to be evaluated dynamically.

app/items/route.ts

```ts
import { NextResponse } from 'next/server';

export async function POST() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
    body: JSON.stringify({ time: new Date().toISOString() }),
  });

  const data = await res.json();

  return NextResponse.json(data);
}
```

> **Note:** Previously, API Routes could have been used for use cases like handling form submissions. Route Handlers are likely not the solution for these uses cases. We will be recommending the use of [mutations](/docs/app/building-your-application/data-fetching/server-actions) for this when ready.

## [Examples](#examples)

The following examples show how to combine Route Handlers with other Next.js APIs and features.

### [Revalidating Static Data](#revalidating-static-data)

You can [revalidate static data](https://beta.nextjs.org/docs/data-fetching/revalidating) fetches using the [`next.revalidate`](/docs/app/building-your-application/data-fetching/fetching#revalidating-data) option:

app/items/route.ts

```ts
import { NextResponse } from 'next/server';

export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    next: { revalidate: 60 }, // Revalidate every 60 seconds
  });
  const data = await res.json();

  return NextResponse.json(data);
}
```

Alternatively, you can use the [`revalidate` segment config option](/docs/app/api-reference/file-conventions/route-segment-config#revalidate):

    export const revalidate = 60;

### [Dynamic Functions](#dynamic-functions)

Route Handlers can be used with dynamic functions from Next.js, like [`cookies`](/docs/app/api-reference/functions/cookies) and [`headers`](/docs/app/api-reference/functions/headers).

#### [Cookies](#cookies)

You can read cookies with [`cookies`](/docs/app/api-reference/functions/cookies) from `next/headers`. This server function can be called directly in a Route Handler, or nested inside of another function.

This `cookies` instance is read-only. To set cookies, you need to return a new `Response` using the [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) header.

app/api/route.ts

```ts
import { cookies } from 'next/headers';

export async function GET(request: Request) {
  const cookieStore = cookies();
  const token = cookieStore.get('token');

  return new Response('Hello, Next.js!', {
    status: 200,
    headers: { 'Set-Cookie': `token=${token}` },
  });
}
```

Alternatively, you can use abstractions on top of the underlying Web APIs to read cookies ([`NextRequest`](/docs/app/api-reference/functions/next-request)):

app/api/route.ts

```ts
import { type NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
  const token = request.cookies.get('token');
}
```

#### [Headers](#headers)

You can read headers with [`headers`](/docs/app/api-reference/functions/headers) from `next/headers`. This server function can be called directly in a Route Handler, or nested inside of another function.

This `headers` instance is read-only. To set headers, you need to return a new `Response` with new `headers`.

app/api/route.ts

```ts
import { headers } from 'next/headers';

export async function GET(request: Request) {
  const headersList = headers();
  const referer = headersList.get('referer');

  return new Response('Hello, Next.js!', {
    status: 200,
    headers: { referer: referer },
  });
}
```

Alternatively, you can use abstractions on top of the underlying Web APIs to read headers ([`NextRequest`](/docs/app/api-reference/functions/next-request)):

app/api/route.ts

```ts
import { type NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
  const requestHeaders = new Headers(request.headers);
}
```

### [Redirects](#redirects)

app/api/route.ts

```ts
import { redirect } from 'next/navigation';

export async function GET(request: Request) {
  redirect('https://nextjs.org/');
}
```

### [Dynamic Route Segments](#dynamic-route-segments)

> We recommend reading the [Defining Routes](/docs/app/building-your-application/routing/defining-routes) page before continuing.

Route Handlers can use [Dynamic Segments](/docs/app/building-your-application/routing/defining-routes#dynamic-segments) to create request handlers from dynamic data.

app/items/\[slug\]/route.js

```ts
export async function GET(
  request: Request,
  {
    params,
  }: {
    params: { slug: string };
  },
) {
  const slug = params.slug; // 'a', 'b', or 'c'
}
```

<table><thead><tr><th>Route</th><th>Example URL</th><th><code>params</code></th></tr></thead><tbody><tr><td><code>app/items/[slug]/route.js</code></td><td><code>/items/a</code></td><td><code>`{ slug: 'a' }`</code></td></tr><tr><td><code>app/items/[slug]/route.js</code></td><td><code>/items/b</code></td><td><code>`{ slug: 'b' }`</code></td></tr><tr><td><code>app/items/[slug]/route.js</code></td><td><code>/items/c</code></td><td><code>`{ slug: 'c' }`</code></td></tr></tbody></table>
app/api/route.ts

```ts
// https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#convert_async_iterator_to_stream
function iteratorToStream(iterator: any) {
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await iterator.next();

      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
  });
}

function sleep(time: number) {
  return new Promise((resolve) => {
    setTimeout(resolve, time);
  });
}

const encoder = new TextEncoder();

async function* makeIterator() {
  yield encoder.encode('<p>One</p>');
  await sleep(200);
  yield encoder.encode('<p>Two</p>');
  await sleep(200);
  yield encoder.encode('<p>Three</p>');
}

export async function GET() {
  const iterator = makeIterator();
  const stream = iteratorToStream(iterator);

  return new Response(stream);
}
```

### [Request Body](#request-body)

You can read the `Request` body using the standard Web API methods:

app/items/route.ts

```ts
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const res = await request.json();
  return NextResponse.json({ res });
}
```

### [CORS](#cors)

You can set CORS headers on a `Response` using the standard Web API methods:

app/api/route.ts

```ts
export async function GET(request: Request) {
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
```

### [Edge and Node.js Runtimes](#edge-and-nodejs-runtimes)

Route Handlers have an isomorphic Web API to support both Edge and Node.js runtimes seamlessly, including support for streaming. Since Route Handlers use the same route segment configuration as pages and layouts, they support long-awaited features like general-purpose [statically regenerated](/docs/app/building-your-application/data-fetching/revalidating) Route Handlers.

You can use the `runtime` segment config option to specify the runtime:

    export const runtime = 'edge'; // 'nodejs' is the default

### [Non-UI Responses](#non-ui-responses)

You can use Route Handlers to return non-UI content. Note that [`sitemap.xml`](/docs/app/api-reference/file-conventions/metadata#sitemap), [`robots.txt`](/docs/app/api-reference/file-conventions/metadata#robots=file), [`favicon.ico`](/docs/app/api-reference/file-conventions/metadata#app-icons), and [open graph images](/docs/app/api-reference/file-conventions/metadata#open-graph-images) all have built-in SEO support.

app/rss.xml/route.ts

```ts
export async function GET() {
  return new Response(`<?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0">

    <channel>
      <title>Next.js Documentation</title>
      <link>https://nextjs.org/docs</link>
      <description>The React Framework for the Web</description>
    </channel>

    </rss>`);
}
```

### [Segment Config Options](#segment-config-options)

Route Handlers use the same route segment configuration as pages and layouts.

app/items/route.ts

```ts
export const dynamic = 'auto';
export const dynamicParams = true;
export const revalidate = false;
export const fetchCache = 'auto';
export const runtime = 'nodejs';
export const preferredRegion = 'auto';
```

# useSelectedLayoutSegment

`useSelectedLayoutSegment` is a **Client Component** hook that lets you read the active route segment **one level below** the Layout it is called from.

It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.

app/example-client-component.tsx

```ts
'use client';

import { useSelectedLayoutSegment } from 'next/navigation';

export default function ExampleClientComponent() {
  const segment = useSelectedLayoutSegment();

  return <>Active segment: {segment}</>;
}
```

**Good to know:**

- Since `useSelectedLayoutSegment` is a [Client Component](/docs/getting-started/react-essentials#client-components) hook, and Layouts are [Server Components](/docs/getting-started/react-essentials#server-components) by default, `useSelectedLayoutSegment` is usually called via a Client Component that is imported into a Layout.
- `useSelectedLayoutSegment` only returns the segment one level down. To return all active segments, see [`useSelectedLayoutSegments`](/docs/app/api-reference/functions/use-selected-layout-segments)

## [Parameters](#parameters)

```ts
const segment = useSelectedLayoutSegment();
```

`useSelectedLayoutSegment` does not take any parameters.

## [Returns](#returns)

`useSelectedLayoutSegment` returns a string of the active segment or `null` if one doesn't exist.

For example, given the Layouts and URLs below, the returned segment would be:

<table>
  <thead>
    <tr>
      <th>Layout</th>
      <th>Visited URL</th>
      <th>Returned Segment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>app/layout.js</code>
      </td>
      <td>
        <code>/</code>
      </td>
      <td>
        <code>null</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>app/layout.js</code>
      </td>
      <td>
        <code>/dashboard</code>
      </td>
      <td>
        <code>'dashboard'</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>app/dashboard/layout.js</code>
      </td>
      <td>
        <code>/dashboard</code>
      </td>
      <td>
        <code>null</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>app/dashboard/layout.js</code>
      </td>
      <td>
        <code>/dashboard/settings</code>
      </td>
      <td>
        <code>'settings'</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>app/dashboard/layout.js</code>
      </td>
      <td>
        <code>/dashboard/analytics</code>
      </td>
      <td>
        <code>'analytics'</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>app/dashboard/layout.js</code>
      </td>
      <td>
        <code>/dashboard/analytics/monthly</code>
      </td>
      <td>
        <code>'analytics'</code>
      </td>
    </tr>
  </tbody>
</table>

## [Examples](#examples)

### [Creating an active link component](#creating-an-active-link-component)

You can use `useSelectedLayoutSegment` to create an active link component that changes style depending on the active segment. For example, a featured posts list in the sidebar of a blog:

app/blog/blog-nav-link.tsx

```ts
'use client';

import Link from 'next/link';
import { useSelectedLayoutSegment } from 'next/navigation';

// This *client* component will be imported into a blog layout
export default function BlogNavLink({
  slug,
  children,
}: {
  slug: string;
  children: React.ReactNode;
}) {
  // Navigating to `/blog/hello-world` will return 'hello-world'
  // for the selected layout segment
  const segment = useSelectedLayoutSegment();
  const isActive = slug === segment;

  return (
    <Link
      href={`/blog/${slug}`}
      // Change style depending on whether the link is active
      style={{ fontWeight: isActive ? 'bold' : 'normal' }}
    >
      {children}
    </Link>
  );
}
```

app/blog/layout.tsx

```ts
// Import the Client Component into a parent Layout (Server Component)
import { BlogNavLink } from './blog-nav-link';
import getFeaturedPosts from './get-featured-posts';

export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const featuredPosts = await getFeaturedPosts();
  return (
    <div>
      {featuredPosts.map((post) => (
        <div key={post.id}>
          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>
        </div>
      ))}
      <div>{children}</div>
    </div>
  );
}
```

# usePathname

`usePathname` is a **Client Component** hook that lets you read the current URL's **pathname**.

app/example-client-component.tsx

```ts
'use client';

import { usePathname } from 'next/navigation';

export default function ExampleClientComponent() {
  const pathname = usePathname();
  return <>Current pathname: {pathname}</>;
}
```

**Good to know:**

- `usePathname` is a [Client Component](/docs/getting-started/react-essentials) hook and is **not supported** in [Server Components](/docs/getting-started/react-essentials).
- `usePathname` can return `null` when a [fallback route](/docs/pages/building-your-application/data-fetching/get-static-paths#fallback-pages) is being rendered or when a `pages` directory page has been [automatically statically optimized](/docs/pages/building-your-application/rendering/automatic-static-optimization) by Next.js and the router is not ready.
  - Next.js will automatically update your types if it detects both an `app` and `pages` directory in your project.

## [Parameters](#parameters)

```ts
const pathname = usePathname();
```

`usePathname` does not take any parameters.

## [Returns](#returns)

`usePathname` returns a string of the current URL's pathname. For example:

<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>Returned value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>/</code>
      </td>
      <td>
        <code>'/'</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>/dashboard</code>
      </td>
      <td>
        <code>'/dashboard'</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>/dashboard?v=2</code>
      </td>
      <td>
        <code>'/dashboard'</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>/blog/hello-world</code>
      </td>
      <td>
        <code>'/blog/hello-world'</code>
      </td>
    </tr>
  </tbody>
</table>

## [Examples](#examples)

### [Do something in response to a route change](#do-something-in-response-to-a-route-change)

app/example-client-component.tsx

```ts
'use client';

import { usePathname, useSearchParams } from 'next/navigation';

function ExampleClientComponent() {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  useEffect(() => {
    // Do something here...
  }, [pathname, searchParams]);
}
```
